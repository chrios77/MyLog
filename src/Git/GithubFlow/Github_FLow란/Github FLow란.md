# Github FLow란?

### Github FLow란?
친구와 **'나무 기록장'**이라는 걸 만들었다고 생각해자. '나무 기록장'은 나무에 대한 **모든 정보를 기록하는 노트**이다.

이제 '나무 기록장'을 **여러 친구들과 같이 작업**하려고 하는데, **동시에 노트를 수정하면 누가 뭘 바꾸었는지 알기 어렵고, 망가질 수도 있다.** 이런 문제를 **'충돌'**이라고 한다. 그런데 이 **'충돌'을 해결해주는 방법**이 바로 **깃허브 플로우(Github Flow)**다.

먼저, **'나무 기록장'의 복사본을 만든다.** 이걸 **'브랜치'**라고 하는데 **본문에서 손상을 방지하기 위해 따로 작업하는 곳**이다.

이렇게 하면 원본 '나무 기록장'이 망가지는 걸 방지할 수 있다. **'브랜치'에서 자유롭게 나무에 대한 정보를 수정하거나 추가한다.** 이건 마치 **자신만의 '나무 기록장'을 가지고 작업하는 것과 같다.**

수정이 끝났다면, 이 **수정사항을 원본 '나무 기록장'에 이 정보를 넣을 준비**가 된 것이다. 이걸 **'풀 리퀘스트(PR, Pull Request)'**라고 합니다. **다른 친구들에게 "이 정보를 본문에 넣어도 될까요?" 라고 물어보는 것**이다. 이건 마치 "내가 수정한 부분을 원본에 넣어도 될까요?"라고 허락받는 것이다.

친구들이 **확인하고 문제가 없다면**, 이제 **'나무 기록장' 본문을 수정할 수 있게 된다.** 이걸 **'병합'**이라고 한다. 즉, 다른 **친구들이 이 '풀 리퀘스트'를 확인하고, 문제가 없다면 이제 원본 '나무 기록장'에 병합한다.** 이건 마치 "네, 수정사항이 좋아요. 원본에 넣어도 돼요."라고 말하는 것과 같다.

**병합이 끝나면, 더 이상 '브랜치'는 필요 없으니 없애버린다.**

이렇게 깃허브 플로우를 사용하면 여러 사람이 동시에 '나무 기록장'을 수정하더라도, **누가 무엇을 바꾸었는지 알 수 있고, '나무 기록장'이 망가지지 않는다.**

그래서 깃허브 플로우는 '충돌'을 해결해주는 똑똑한 방법이라고 생각하면 된다.



